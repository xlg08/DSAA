TimSort排序算法

## 概要

>​	TimSort是由TimPeters为Python设计的一种排序算法，结合了插入排序和归并排序的优点，具有较好的平均时间复杂度O(nlogn)和稳定性。
>
>​	TimSort首先将数据分成小块并使用插入排序，然后用归并排序合并这些块，特别适合已部分排序的数据。该算法已被Python、Java等语言采纳为默认排序算法。

## 其他算法性能

![1744900749676](C:\Users\LG\AppData\Roaming\Typora\typora-user-images\1744900749676.png)

> ​	上述算法中，日常用的最多的一般是快速排序和堆排序，这两个算法都是性能很高的排序算法，缺点是不稳定。而 TimSort 算法性能比快速排序和堆排序还高，且是稳定排序算法。

## 简介

> ​	TimSort 算法是 Tim Peters（就是写  Python 之禅  的那个大神） 于 2001 年为 Python 语言创建的。该算法建立在插入排序和归并排序的基础之上，兼具插入排序和归并排序的优点。

>​	TimSort 的平均时间复杂度为 O ( n log ⁡ n ) ，最好情况 O ( n ) ，最差情况 O ( n log ⁡ n )  。空间复杂度 O ( n ) ，是一个稳定的排序算法。

> Java 中的 `Arrays.sort()`，Python 中的 `sort()` 和 `sorted()` 背后用的都是 TimSort。

## 原理

>​	TimSort 的排序思想并不复杂，首先使用插入排序对小块进行排序，然后使用归并排序合并这些块。
>
>​	TimSort 会将数组（列表）分成名为 Run 的小块。
>
>​		首先使用插入排序对这些 run 块进行排序，
>
>​		然后使用归并排序中的 combine 函数合并这些 run 块。
>
>​		如果数组的大小小于 run 块的大小，则仅使用插入排序对数组进行排序。
>
>​		run 块的大小可能从 32 到 64 不等，具体取决于数组的大小。
>
>​	注意：子数组的大小尽量是 2 的幂，这样 merge 函数性能表现会更好。

### 逐步解释

>​	使用插入排序将输入数组分成小的 run块。每个 run 块都为递增顺序。
>​	然后使用改进的归并排序算法合并 run 块。合并步骤的工作原理是比较 每个run 块的第一个元素，并将最小的元素添加到输出数组。该过程一直持续到所有元素都添加到输出数组。
>​	如果 run 块不是良构的，即有些不是按升序排列的，那么它们将合并在一起直到它们为良构的。
>​	run 块的大小在每次迭代中增加两倍，直到整个数组排序完成。

>​	TimSort 的想法是基于插入排序对小数组表现良好的事实，因此在最好情况下可以获得插入排序 O ( n )  的最好性能。同时又能获得归并排序最差 O ( n log ⁡ n )的性能表现。

### 详解

#### 小数组用插入排序

>如果数组比较小（通常是小于 2 ^6 = 64 ），那么 TimSort 会直接采用插入排序对数组进行排序。
>
>因为插入排序作为一种简单的排序算法，对小列表最有效。在较大的列表中非常慢，但在小列表中非常快。 插入排序的思想如下：
>
> - 逐个扫一遍数组元素
>
> - 通过在正确位置插入元素来构建排序数组
>
>   ​			插入排序的过程：
>
>![img](https://i-blog.csdnimg.cn/blog_migrate/4bfe7094c1b1f661386349a7323e9664.gif)

#### Run 块

>​	如果列表比较大，则算法会先遍历列表，查找严格递增或递减的部分。如果该部分是递减的，则将其反转成递增的。
>
>​	假如：数组元素是 [3,2,1,9,17,34]，遍历发现前3个元素是递减的，则 run 块会将其变为递增的，即：[1,2,3,9,17,34]。
>
>​	当 run 块的数量等于或略小于 2 的幂时，合并 2 个数组的效率会更高。Timsort 通过确保 minrun 等于或小于 2 的幂来保证合并的效率。 minrun 的取值范围一般在 32 到 64 之间（含）。选定的 minrun 值要确保原始数组的长度除以 minrun 后等于或略小于 2 的幂。
>
>​	如果 run 块的长度小于 minrun，则计算该 run 块长度与 minrun 的偏离，看看 run 块还差多少元素并执行插入排序以创建新 run 块。
>
>​	这部分完成后，将得到一堆排序好的 run 块。

#### 归并

> ​	此步，Timsort 执行归并排序将 run 块合并在一起。这里，Timsort 需要确保在归并排序时保持稳定性和合并平衡。
>
> ​	为了保持稳定性，算法就不应该交换 2 个等值的数。这不仅保留了它们在列表中的原始位置，而且使算法更快。
>
> ​	当 Timsort 发现 run 块时，会将它们添加到栈中。栈是先进后出的。
>
> ​	Timsort 试图在归并排序 run 块时平衡两种相互竞争的需求。一方面，希望尽可能地延迟合并，以便利用稍后可能出现的模式。但更希望尽快进行合并，以利用刚刚发现的处于栈顶的 run 块，因此也不能将合并延迟“太久”，因为它会消耗更多内存来记住仍未合并的 run 块，并且栈的大小是有限的。
>
> ​	为了找到最优折中方案，Timsort 会跟踪栈中最近的三个项并规定如下 2 个法则：
>
> ​		1.A > B + C
> ​		2.B > C
> ​	其中 A , B , C A,B,CA,B,C 是栈中最近的三个项。
>
> 		>用 Tim Peters 的原话说：
> 		>
> 		>​	结果证明这是一个很好的折衷方案，在栈顶维护两个不变量，其中 A、B 和 C 是三个最右边尚未合并的切片的长度。
>
> ​	通常，将不同长度的相邻 run 块合并到位是很困难的。更难的是必须保持稳定。为了解决这个问题，Timsort 预留了临时内存。它将两个 run 块中较小的（同时调用 run A 和 run B）放入该临时内存中。
>

## 总结

> Timsort 实际上已经内置于 Python 中。
>
> 在 Python 要使用 Timsort，只需 `list.sort()` 或 `sorted(list)` 即可。













